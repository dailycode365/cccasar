const e=require("fire-path"),t=(require("async"),require("lodash"),require("fire-fs")),i=require("./utils"),r=e.join(Editor.remote.Project.path,"temp/TexturePacker/preview"),a=e.join(Editor.remote.Project.path,"temp/TexturePacker/build"),s="raw-assets";class n{async init(e){this.writer=e.writer,this.platform=e.platform,this.needPackSpriteFrames=[];let t=await i.queryAtlases(e.files);this.spriteFrames=t.spriteFrames,this.pacInfos=t.pacInfos,this.textureUuids=t.textureUuids,this.texture2pac=t.texture2pac}needPack(e){if(-1!==this.textureUuids.indexOf(e))return!0;let t=this.spriteFrames;for(let r=0;r<t.length;r++){var i=t[r];if(i._uuid===e)return-1===this.needPackSpriteFrames.indexOf(i)&&this.needPackSpriteFrames.push(i),!1}return!1}async pack(){let r=[],n=Object.create(null),u=Object.create(null),o={dest:e.join(a,s),pacInfos:this.pacInfos,needPackSpriteFrames:this.needPackSpriteFrames,needCompress:!0},d=await i.pack(o);return await Promise.all(d.map(async i=>{r=r.concat(i.unpackedTextures);let a=i.pacInfo,o=new cc.SpriteAtlas;o._uuid=a.info.uuid,await Promise.all(i.atlases.map(async i=>{let r=require("../hash-uuid"),a=i.files.map(e=>e.uuid),d=r.calculate([a],r.BuiltinHashType.AutoAtlasTexture)[0];if(!i.compressd)throw"Cann't find atlas.compressed.";let c=i.compressd.suffix,p=e.join(this.writer.dest,"..",s,d.slice(0,2),d);await Promise.all(c.map(async e=>{await new Promise((r,a)=>{let s=i.compressd.imagePathNoExt+e,n=p+e;t.copy(s,n,e=>{if(e)return a(e);r()})})}));let l=new cc.Texture2D;l._exportedExts=c,l._uuid=d,l.width=i.width,l.height=i.height,await this.write(l);let h=p+".png";u[d]=h,await Promise.all(i.files.map(async e=>{if(-1===this.needPackSpriteFrames.indexOf(e.spriteFrame))return;let t=this.generateSpriteFrame(e,o._uuid,d);n[t._uuid]=d,o._spriteFrames[e.name]=Editor.serialize.asAsset(t._uuid),await this.write(t)}))})),await this.write(o)})),{unpackedTextures:r,packedSpriteFrames:n,packedTextures:u}}generateSpriteFrame(e,t,i){let r=new cc.SpriteFrame,a=e.spriteFrame;r._name=e.name,r._atlasUuid=t,r._uuid=a._uuid;let s=e.trim;return r._rect=cc.rect(s.x,s.y,s.width,s.height),r._offset=a.getOffset(),r._originalSize=cc.size(e.rawWidth,e.rawHeight),r._rotated=e.rotated,r.insetLeft=a.insetLeft,r.insetTop=a.insetTop,r.insetRight=a.insetRight,r.insetBottom=a.insetBottom,r._texture=Editor.serialize.asAsset(i),r}async write(e,t){let i=Editor.serialize(e,{exporting:!0,nicify:!0,stringify:!1,dontStripDefault:!1});await new Promise((t,r)=>{this.writer.writeJsonByUuid(e._uuid,i,e=>{if(e)return r(e);t()})})}}n.generatePreviewFiles=async function(e){let t=Editor.remote.assetdb.assetInfoByUuid(e),a=r,s=await i.queryAtlases(t);await i.pack({pacInfos:s.pacInfos,dest:a})},n.queryPreviewInfo=function(i,a){let s=Editor.url("db://assets"),n=Editor.remote.assetdb.assetInfoByUuid(i),u=e.relative(s,e.dirname(n.path)),o=e.join(r,u,e.basename(n.path)),d=e.join(o,"info.json");if(!t.existsSync(d))return a(null);let c=t.readJSONSync(d);if(!c.result)return a(null);a(null,{packedTextures:c.result.atlases.map(t=>({path:t.imagePath,name:e.basename(t.imagePath),size:t.width+"x"+t.height})),unpackedTextures:c.result.unpackedTextures.map(t=>{let i=t.originalPath||t.path,r=Editor.assetdb.remote.uuidToFspath(t.textureUuid);return{path:i,name:e.basename(r),size:t.width+"x"+t.height}})})},module.exports=n;